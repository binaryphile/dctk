#!/usr/bin/env bash
# Completions: true

source kaizen.bash
$(bring '
  dirname
  echo
  readlink
' from kaizen.commands)

prog=${_DCTK_PROG:-dctk}
libexec=$($dirname "$($readlink "$BASH_SOURCE")")

get <<'EOS'
  Usage: %s <command> [<args>]

  Some useful %s commands are:
    %%s
  See '%s help <command>' for information on a specific command.\n
EOS
printf -v usage "$__" "$prog" "$prog" "$prog"

main () {
  $(grab complete_flag from "$1"); shift
  local path

  (( complete_flag  ))          && exec "$libexec"/commands
  (( $#             ))          || $die "$usage"
  command_path "$libexec" "$1"  || $die
  path=$__
  usage "$path"
  $echo "$__"
  help "$path"
  given? "$__" && $echo $'\n'"$__";:
}

command_path () {
  __=$(command -v "$1/$2") || __=$(command -v "$1"/sh-"$2") || $(raise CommandNotFoundError "$prog:  no such command '$2'")
}

help () {
  __=$(awk '/^[^#]/{p=0} /^# Help:/{p=1} p' "$1" | sed "s/^# Help: //;s/^# //;s/^#//")
  given? "$__" && printf -v __ "$__" "$prog"
}

summaries () {
  local columns
  local command
  local command_ary=()
  local file
  local format
  local index
  local libexec=$1
  local longest_command=0
  local result_ary=()
  local summary_ary=()
  local summary_length

  columns=$(tput cols)
  for command in $("$libexec"/commands); do
    command_path "$libexec" "$command"
    file=$__
    ! symlink? "$file" || continue
    summary "$file"
    given? "$__" || continue
    summary_ary+=( "$__" )
    command_ary+=( "$command" )
    longest_command=$(( ${#command} > longest_command ? ${#command} : longest_command ))
  done
  summary_length=$(( columns - longest_command - 5 ))
  for index in "${!command_ary[@]}"; do
    printf -v format "%%-%ss  %%s\n" "$longest_command"
    truncate summary_length "${summary_ary[index]}"
    printf -v __ "$format" "${command_ary[index]}" "$__"
  done
}

summary () {
  __=$(sed -n -e "s/^# Summary: \(.*\)/\1/p" "$1")
  given? "$__" && printf -v __ "$__" "$prog";:
}

truncate () {
  local max_length=$1
  local string=$2
  local length

  (( ${#string} > max_length )) || { __=$string; return ;}
  length=$(( max_length - 3 ))
  __=${string:0:$length}...
}

usage () {
  __=$(sed -n "s/^# \(Usage: .*\)/\1/p" "$1")
  given? "$__" && printf -v __ "$__" "$prog" || __="Sorry, this command is not documented yet."
}

sourced? && return
strict_mode on

summaries "$libexec"
printf -v usage "$usage" "$__"

$echo
(( ! $# )) && die "$usage"
get <<'EOS'
  ''  --complete  ''  "completions"
EOS
$(parse_options "$__" "$@") || $die "$usage"
main "$__" "$@"             || $die "$usage"
