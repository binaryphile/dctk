#!/usr/bin/env bash
# Completions: true

[[ -n $_dctk_help ]] && return
readonly _dctk_help=loaded

source kzn.bash
initialize_kzn

define usage_message <<'EOS'
Usage: %s <command> [<args>]

Some useful %s commands are:
%s

See '%s help <command>' for information on a specific command.\n
EOS

prog=${_DCTK_PROG:-dctk}

error_message="%s: no such command '%s'"

main() {
  local command
  local file
  local libexec

  libexec=$(realpath "$BASH_SOURCE")
  libexec=$(dirname "$libexec")

  is_same_as --complete "${1:-}" && exec "$libexec"/commands

  command=${1:-}
  case $command in
    "" )
      # shellcheck disable=SC2059,SC2154
      printf "$usage_message" "$prog" "$prog" "$(print_summaries "$libexec")" "$prog"
      ;;
    * )
      file=$(command_path "$command" "$libexec")
      # shellcheck disable=SC2059
      is_given "$file" || errexit "$(printf "$error_message\n" "$prog" "$command")"
      print_help "$file"
      ;;
  esac
}

command_path() {
  local command=$1
  local libexec=$2

  command -v "$libexec"/"$command" || command -v "$libexec"/sh-"$command" ||:
}

help() {
  # shellcheck disable=SC2059
  printf "$(awk '/^[^#]/{p=0} /^# Help:/{p=1} p' "$1" | sed "s/^# Help: //;s/^# //;s/^#//")" "$prog"
}

print_help() {
  local file=$1
  local help
  local usage

  usage=$(usage "$file")
  is_given "$usage" || { puts "Sorry, this command isn't documented yet."; return 0 ;}
  puts "$usage"
  help=$(help "$file")
  is_given "$help" && printf "\n%s\n" "$help"
  return 0
}

print_summaries() {
  local -a commands
  local -a summaries
  local columns
  local command
  local file
  local format
  local index
  local libexec=$1
  local longest_command=0
  local summary
  local summary_length

  columns=$(tput cols)

  for command in $("$libexec"/commands); do
    file=$(command_path "$command" "$libexec")
    ! is_symlink "$file" || continue
    summary=$(summary "$file")
    is_given "$summary" || continue
    commands+=( "$command" )
    summaries+=( "$summary" )
    longest_command=$(( ${#command} > longest_command ? ${#command} : longest_command ))
  done

  summary_length=$(( columns - longest_command - 5 ))

  for index in "${!commands[@]}"; do
    printf -v format "   %%-%ss  %%s\n" "$longest_command"
    # shellcheck disable=SC2059
    printf "$format" "${commands[$index]}" \
      "$(truncate "$summary_length" "${summaries[$index]}")"
  done
}

# shellcheck disable=SC2059
summary() { printf "$(sed -n -e "s/^# Summary: \(.*\)/\1/p" "$1")" "$prog" ;}

truncate() {
  local max_length=$1
  local string=$2

  (( ${#string} > max_length )) || { puts "$string"; return ;}
  local length=$(( max_length - 3 ))
  puts "${string:0:$length}..."
}

# shellcheck disable=SC2059
usage() { printf "$(sed -n "s/^# \(Usage: .*\)/\1/p" "$1")" "$prog" ;}

return 0 2>/dev/null ||:

strict_mode on
main "$@"
